define([], function(){
	return function(obj) {
obj || (obj = {});
var __t, __p = '';
with (obj) {
__p += 'define(' +
((__t = ( imports )) == null ? '' : __t) +
', function(' +
((__t = ( args )) == null ? '' : __t) +
'){\n\n	var tokens = ' +
((__t = ( intermediate )) == null ? '' : __t) +
';\n\n	var supportsCreatingScripts = (function(){\n		try { document.createElement("script").appendChild(document.createDocumentFragment()); return true; } catch(_) { return false; }\n	})();\n\n	// For IE8 strip out the scripts because they will be executed prematurely.\n	if(!supportsCreatingScripts) {\n		var removeTag = function(tag){\n			var i = 0, item;\n			while(i < tokens.length) {\n				item = tokens[i], j = i;\n				if(item.tokenType === "start" && item.args && item.args[0] === tag) {\n					do {\n						item = tokens[j]; j++;\n					}\n					while(j < tokens.length && !(item.tokenType === "close" && item.args && item.args[0] === tag ));\n					tokens.splice(i, j - i);\n				}\n				i++;\n			}\n		};\n		removeTag("script");\n	}\n\n	var renderer = stache(tokens);\n\n	var isNode = typeof process === "object" && {}.toString.call(process) === "[object process]";\n\n	if(!isNode) {\n		// SSR helpers isProduction, and some that don\'t matter in the client.\n		stache.registerHelper("isProduction", function(options){\n			var loader = typeof System !== "undefined" ? System : undefined;\n			if(loader && loader.isEnv && loader.isEnv("production")) {\n				return options.fn(this);\n			} else {\n				return options.inverse(this);\n			}\n		});\n		stache.registerHelper("asset", can.k);\n	}\n\n	var __export = {\n		renderToFrag: function(scope, options){\n			var moduleOptions = { module: module };\n			options = (options && options.add) ? options.add(moduleOptions) :\n				moduleOptions;\n			return renderer(scope, options);\n		},\n		start: function(){\n			var state = this.state = new this.viewModel;\n			if (can.route) {\n				can.route.map(state);\n				can.route.ready();\n			}\n			this.rerender();\n		},\n		rerender: function(){\n			var keep = { "SCRIPT": true, "STYLE": true, "LINK": true };\n			function eachChild(parent, callback){\n				can.each(can.makeArray(parent.childNodes), function(el){\n					if(!keep[el.nodeName]) {\n						callback(el);\n					}\n				});\n			}\n\n			function remove(el) {\n				can.remove(can.$(el));\n			}\n\n			function appendTo(parent){\n				return function(el){\n					can.appendChild(parent, el);\n				}\n			}\n\n			this.renderAsync().then(function(result){\n				var frag = result.fragment;\n				var head = document.head || document.getElementsByTagName("head")[0];\n				var body = document.body;\n\n				// Move elements from the fragment\'s head to the document head.\n				eachChild(head, remove);\n				eachChild(can.$("head", frag)[0], appendTo(head));\n\n				// Move elements from the fragment\'s body to the document body.\n				eachChild(body, remove);\n				eachChild(can.$("body", frag)[0], appendTo(body));\n			});\n		},\n		renderAsync: function(renderer, data, options, doc){\n			renderer = renderer || this.renderToFrag;\n			data = data || this.state;\n			options = options || {};\n\n			var frag;\n			return wait(function(){\n				frag = renderer(data, options);\n\n				if(doc) {\n					var oldDoc = can.document;\n					can.document = doc;\n					can.appendChild(doc.body, frag, doc);\n					can.document = oldDoc;\n				}\n			}).then(function(responses){\n				return {\n					fragment: frag,\n					data: data.__pageData,\n					canWaitData: responses\n				};\n			}, function(errors) {\n				throw errors;\n			});\n		},\n		legacy: false,\n		render: function(doc, state){\n			var renderer = this.renderToFrag;\n			var frag = renderer(state, {});\n\n			var oldDoc = can.document;\n			can.document = doc;\n			can.appendChild(doc.body, frag, doc);\n			can.document = oldDoc;\n		},\n		' +
((__t = ( ases )) == null ? '' : __t) +
'\n	};\n	var __isNW = (function(){\n		try{var nr = System._nodeRequire; return nr && nr(\'nw.gui\') !== \'undefined\';}catch(e){return false;}\n	})();\n\n	if(typeof steal !== \'undefined\' && (__isNW || !(typeof process === \'object\' && {}.toString.call(process) === \'[object process]\')))\n		steal.done().then(function() { __export.start(); });\n\n	return __export;\n});\n';

}
return __p
}
});